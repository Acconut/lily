<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
        <meta name="description" content="The Lily Programming Language, reference">
        <meta name="author" content="Jesse Ray Adkins">

        <title>Lily Language Reference</title>

        <!-- Bootstrap core CSS -->
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <!-- Bootstrap theme -->
        <link href="css/bootstrap-theme.min.css" rel="stylesheet">
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <link href="css/ie10-viewport-bug-workaround.css" rel="stylesheet">

        <link rel="stylesheet" href="css/theme.css">
        <link rel="stylesheet" href="css/doc.css">

        <script src="js/ie-emulation-modes-warning.js"></script>
    </head>

    <body role="document">
        <nav class="navbar navbar-inverse navbar-static-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">Lily</a>
                </div>

                <div id="navbar" class="navbar-collapse collapse">
                        <ul class="nav navbar-nav">
                            <li><a href="index.html">Home</a></li>
                            <li><a href="tutorial.html">Tutorial</a></li>
                            <li class="active"><a href="#">Reference</a></li>
                            <li><a href="packages.html">Packages</a></li>
                            <li><a href="sandbox.html">Sandbox</a></li>
                            <li><a href="http://github.com/FascinatedBox/lily">Github</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>

        <div class="container theme-showcase" role="main">
<h1>builtin</h1>
<p>The builtin package provides the classes, vars, and functions that form the
foundation of Lily.</p>
<h2>toplevel</h2>
<h3>var stdin: <code>File</code></h3>
<p>Provides a wrapper around the <code>stdin</code> present within C.</p>
<h3>var stderr: <code>File</code></h3>
<p>Provides a wrapper around the <code>stderr</code> present within C.</p>
<h3>var stdout: <code>File</code></h3>
<p>Provides a wrapper around the <code>stdout</code> present within C.</p>
<h3>define print<code>[A](value: A)</code></h3>
<p>Write <code>value</code> to <code>stdout</code>, plus a newline (<code>"\n"</code>). This is equivalent to
<code>stdout.print(value)</code>.</p>
<h4>Errors:</h4>
<ul>
<li><code>IOError</code> if <code>stdout</code> is closed, or not open for reading.</li>
</ul>
<h3>define calltrace<code>: List[String]</code></h3>
<p>Returns a <code>List</code> with one <code>String</code> for each function that is currently entered.</p>
<h3>define assert<code>(condition: Boolean, message: *String="")</code></h3>
<p>If <code>condition</code> is <code>false</code>, raise <code>AssertionError</code> using <code>message</code>.</p>
<h2>class AssertionError</h2>
<pre><code>class AssertionError &lt; Exception {

}
</code></pre>

<p>This is a subclass of <code>Exception</code> that is raised when an <code>assert</code> is passed
<code>false</code> as the first argument.</p>
<h2>class Boolean</h2>
<p>The <code>Boolean</code> class represents a value that is either <code>true</code> or <code>false</code>.</p>
<h3>method Boolean.to_i<code>(self: Boolean): Integer</code></h3>
<p>Convert a <code>Boolean</code> to an <code>Integer</code>. <code>true</code> becomes <code>1</code>, <code>false</code> becomes <code>0</code>.</p>
<h3>method Boolean.to_s<code>(self: Boolean): String</code></h3>
<p>Convert a <code>Boolean</code> to a <code>String</code>.</p>
<h2>class Byte</h2>
<p>The <code>Byte</code> class represents a wrapper over a single <code>Byte</code> value. A <code>Byte</code> value
is always unsigned, giving it a range from 0 to 255. <code>Byte</code> literals are written
using 't' as the suffix on an <code>Integer</code> value.</p>
<h3>method Byte.to_i<code>(self: Byte): Integer</code></h3>
<p>Convert a <code>Byte</code> to an <code>Integer</code>.</p>
<h2>class ByteString</h2>
<p>The <code>ByteString</code> class represents a bag of bytes. A <code>ByteString</code> may have '\0'
values embedded within it. It may also have data that is not valid as utf-8.
The <code>ByteString</code> class currently does not support any primitive operations.</p>
<h3>method ByteString.each_byte<code>(self: ByteString, fn: Function(Byte))</code></h3>
<p>Call <code>fn</code> for each <code>Byte</code> within the given <code>ByteString</code>.</p>
<h3>method ByteString.encode<code>(self: ByteString, encode: *String="error"): Option[String]</code></h3>
<p>Attempt to transform the given <code>ByteString</code> into a <code>String</code>. The action taken
depends on the value of <code>encode</code>.</p>
<p>If encode is <code>"error"</code>, then invalid utf-8 or embedded '\0' values within <code>self</code>
will result in <code>None</code>.</p>
<h3>method ByteString.size<code>(self: ByteString): Integer</code></h3>
<p>Return the number of <code>Byte</code> values within <code>self</code>.</p>
<h3>method ByteString.slice<code>(self: ByteString, start: *Integer=0, stop: *Integer=-1): ByteString</code></h3>
<p>Create a new <code>ByteString</code> copying a section of <code>self</code> from <code>start</code> to <code>stop</code>.</p>
<p>If a negative index is given, it is treated as an offset from the end of <code>self</code>,
with <code>-1</code> being considered the last element.</p>
<p>On error, this generates an empty <code>ByteString</code>. Error conditions are:</p>
<ul>
<li>Either <code>start</code> or <code>stop</code> is out of range.</li>
<li>The <code>start</code> is larger than the <code>stop</code> (reversed).</li>
</ul>
<h2>class DivisionByZeroError</h2>
<pre><code>class DivisionByZeroError &lt; Exception {

}
</code></pre>

<p>The <code>DivisionByZeroError</code> is a subclass of <code>Exception</code> that is raised when
trying to divide or modulo by zero.</p>
<h3>constructor DivisionByZeroError<code>(m: String): DivisionByZeroError</code></h3>
<h2>class Double</h2>
<p>The <code>Double</code> class exists as a wrapper over a C double.</p>
<h3>method Double.to_i<code>(self: Double): Integer</code></h3>
<p>Convert a <code>Double</code> to an <code>Integer</code>. This is done internally through a cast from
a C double, to int64_t, the type of <code>Integer</code>.</p>
<h2>class Dynamic</h2>
<p>The <code>Dynamic</code> class allows defering type checking until runtime. Creation of
<code>Dynamic</code> is done through <code>Dynamic(&lt;value&gt;)</code>. Extraction of values is done
through a cast: <code>.@(type)</code>. The result of a cast is <code>Option[&lt;type&gt;]</code>, with
<code>Some</code> on success and <code>None</code> on failure. Finally, casts are not allowed to hold
polymorphic types, such as <code>List</code> or <code>Hash</code> or <code>Function</code>, because Lily's vm
only holds class information at runtime.</p>
<h3>constructor Dynamic<code>[A](self: A): Dynamic</code></h3>
<p>Constructs a new <code>Dynamic</code> value. Call it using <code>Dynamic(&lt;value&gt;)</code>.</p>
<h2>enum Either</h2>
<pre><code>enum Either[A, B] {
    Left(A)
    Right(B)
}
</code></pre>

<p><code>Either</code> is an enum that holds a <code>Left</code> on failure, or <code>Right</code> on success. It
can be used as the return type of an operation that may fail, and have an error
message to display.</p>
<h3>method Either.is_left<code>[A, B](self: Either[A, B]): Boolean</code></h3>
<p>Return <code>true</code> if <code>self</code> contains a <code>Left</code>, <code>false</code> otherwise.</p>
<h3>method Either.is_right<code>[A, B](self: Either[A, B]): Boolean</code></h3>
<p>Return <code>true</code> if <code>self</code> contains a <code>Right</code>, <code>false</code> otherwise.</p>
<h3>method Either.left<code>[A, B](self: Either[A, B]):Option[A]</code></h3>
<p>If <code>self</code> contains a <code>Left</code>, produces a <code>Some(A)</code>.</p>
<p>If <code>self</code> contains a <code>Right</code>, produces <code>None</code>.</p>
<h3>method Either.right<code>[A, B](self: Either[A, B]): Option[B]</code></h3>
<p>If <code>self</code> contains a <code>Left</code>, produces a <code>None</code>.</p>
<p>If <code>self</code> contains a <code>Right</code>, produces <code>Right(B)</code>.</p>
<h2>class Exception</h2>
<pre><code>class Exception {
    var @message: String
    var @traceback: List[String]
}
</code></pre>

<p>The <code>Exception</code> class is the base class of all exceptions. It defines two
properties: A <code>message</code> as <code>String</code>, and a <code>traceback</code> as <code>List[String]</code>. The
<code>traceback</code> field is rewritten whenever an exception instance is raised.</p>
<h3>constructor Exception<code>(m: String): Exception</code></h3>
<h2>class File</h2>
<p>The <code>File</code> class provides a wrapper over a C FILE * struct. A <code>File</code> is closed
automatically when a scope exits (though not immediately). However, it is also
possible to manually close a <code>File</code>.</p>
<h3>method File.close<code>(self: File)</code></h3>
<p>Close <code>self</code> if it is open, or do nothing if already closed.</p>
<p>For standard streams, this marks the <code>File</code> as closed, but does not actually
close the stream. Embedders, therefore, do not need to worry about standard
streams being altered or closed by Lily.</p>
<h3>method File.each_line<code>(self: File, fn: Function(ByteString))</code></h3>
<p>Read each line of text from <code>self</code>, passing it down to <code>fn</code> for processing.</p>
<h4>Errors</h4>
<ul>
<li><code>IOError</code> if <code>self</code> is not open for reading, or is closed.</li>
</ul>
<h3>method File.open<code>(path: String, mode: String):File</code></h3>
<p>Attempt to open <code>path</code> using the <code>mode</code> given. <code>mode</code> may be one of the
following:</p>
<ul>
<li><code>"r"</code> (read only, must exist)</li>
<li><code>"w"</code> (write only)</li>
<li><code>"a"</code> (append, create if not exist)</li>
<li><code>"r+"</code> (read+write, must exist)</li>
<li><code>"w+"</code> (read+write, creates an empty file if needed)</li>
<li><code>"a+"</code> (read+append)</li>
</ul>
<h4>Errors</h4>
<ul>
<li><code>IOError</code> if unable to open <code>path</code>, or an invalid <code>mode</code> is provided.</li>
</ul>
<h3>method File.print<code>[A](self: File, data: A)</code></h3>
<p>Attempt to write the contents of <code>data</code> to the file provided. <code>data</code> is written
with a newline at the end.</p>
<h4>Errors</h4>
<ul>
<li><code>IOError</code> if <code>self</code> is closed or is not open for writing.</li>
</ul>
<h3>method File.read<code>(self: File, size: *Integer=-1): ByteString</code></h3>
<p>Read <code>size</code> bytes from <code>self</code>. If <code>size</code> is negative, then the full contents of
<code>self</code> are read. This stops if either <code>size</code> bytes are read, or the end of
<code>self</code> is reached.</p>
<h4>Errors:</h4>
<ul>
<li><code>IOError</code> if <code>self</code> is not open for reading, or is closed.</li>
</ul>
<h3>method File.read_line<code>(self: File): ByteString</code></h3>
<p>Attempt to read a line of text from <code>self</code>. Currently, this function does not
have a way to signal that the end of the file has been reached. For now, callers
should check the result against <code>B""</code>. This will be fixed in a future release.</p>
<h4>Errors</h4>
<ul>
<li><code>IOError</code> if <code>self</code> is not open for reading, or is closed.</li>
</ul>
<h3>method File.write<code>[A](self: File, data: A)</code></h3>
<p>Attempt to write the contents of <code>data</code> to the file provided.</p>
<h4>Errors</h4>
<ul>
<li>If <code>self</code> is closed or is not open for writing, <code>IOError</code> is raised.</li>
</ul>
<h2>class Function</h2>
<p>The <code>Function</code> class represents a block of code to be called, which may or may
not produce a value. <code>Function</code> values are first-class, and can be passed around
as arguments, placed into a <code>List</code>, and so on.</p>
<p>The arguments of a <code>Function</code> are denoted within parentheses, with an optional
colon at the end to denote the value returned:</p>
<p><code>Function(Integer): String</code> (return <code>String</code>).</p>
<p><code>Function(String, String)</code> (no value returned).</p>
<h3>method Function.doc<code>(self: Function(1)): String</code></h3>
<p>If <code>self</code> has a docstring, then the docstring is returned. Otherwise, an empty
<code>String</code> is returned instead.</p>
<h2>class Hash</h2>
<p>The <code>Hash</code> class provides a mapping between a key and a value. <code>Hash</code> values can
be created through <code>[key1 =&gt; value1, key2 =&gt; value2, ...]</code>. When writing a
<code>Hash</code>, the key is the first type, and the value is the second.
/
<code>[1 =&gt; "a", 2 =&gt; "b", 3 =&gt; "c"]</code> would therefore be written as
<code>Hash[Integer, String]</code>.</p>
<p>Currently, only <code>Integer</code> and <code>String</code> can be used as keys.</p>
<h3>method Hash.clear<code>[A, B](self: Hash[A, B])</code></h3>
<p>Removes all pairs currently present within <code>self</code>.</p>
<h4>Errors</h4>
<ul>
<li><code>RuntimeError</code> if <code>self</code> is currently being iterated over.</li>
</ul>
<h3>method Hash.delete<code>[A, B](self: Hash[A, B], key: A)</code></h3>
<p>Attempt to remove <code>key</code> from <code>self</code>. If <code>key</code> is not present within <code>self</code>, then
nothing happens.</p>
<h4>Errors</h4>
<ul>
<li><code>RuntimeError</code> if <code>self</code> is currently being iterated over.</li>
</ul>
<h3>method Hash.each_pair<code>[A, B](self: Hash[A, B], fn: Function(A, B))</code></h3>
<p>Iterate through each pair that is present within <code>self</code>. For each of the pairs,
call <code>fn</code> with the key and value of each pair.</p>
<h3>method Hash.get<code>[A, B](self: Hash[A, B], key: A, default: B): B</code></h3>
<p>Attempt to find <code>key</code> within <code>self</code>. If <code>key</code> is present, then the value
associated with it is returned. If <code>key</code> cannot be found, then <code>default</code> is
returned instead.</p>
<h3>method Hash.has_key<code>[A, B](self: Hash[A, B], key: A):Boolean</code></h3>
<p>Return <code>true</code> if <code>key</code> is present within <code>self</code>, <code>false</code> otherwise.</p>
<h3>method Hash.keys<code>[A, B](self: Hash[A, B]): List[A]</code></h3>
<p>Construct a <code>List</code> containing all values that are present within <code>self</code>. There
is no guarantee of the ordering of the resulting <code>List</code>.</p>
<h3>method Hash.map_values<code>[A, B, C](self: Hash[A, B], Function(B =&gt; C)): Hash[A, C]</code></h3>
<p>This iterates through <code>self</code> and calls <code>fn</code> for each element present. The result
of this function is a newly-made <code>Hash</code> where each value is the result of the
call to <code>fn</code>.</p>
<h3>method Hash.merge<code>[A, B](self: Hash[A, B], others: Hash[A, B]...): Hash[A, B]</code></h3>
<p>Create a new <code>Hash</code> that holds the result of <code>self</code> and each <code>Hash present
within</code>others`.</p>
<p>When duplicate elements are found, the value of the right-most <code>Hash</code> wins.</p>
<h3>method Hash.reject<code>[A, B](self: Hash[A, B], fn: Function(A, B =&gt; Boolean)): Hash[A, B]</code></h3>
<p>This calls <code>fn</code> for each element present within <code>self</code>. The result of this
function is a newly-made <code>Hash</code> containing all values for which <code>fn</code> returns
<code>false</code>.</p>
<h3>method Hash.select<code>[A, B](self: Hash[A, B], fn: Function(A, B =&gt; Boolean)): Hash[A, B]</code></h3>
<p>This calls <code>fn</code> for each element present within <code>self</code>. The result of this
function is a newly-made <code>Hash</code> containing all values for which <code>fn</code> returns
<code>true</code>.</p>
<h3>method Hash.size<code>[A, B](self: Hash[A, B]): Integer</code></h3>
<p>Returns the number of key+value pairs present within <code>self</code>.</p>
<h2>class IndexError</h2>
<pre><code>class IndexError &lt; Exception {

}
</code></pre>

<p>The <code>DivisionByZeroError</code> is a subclass of <code>Exception</code> that is raised when
trying to divide or modulo by zero.</p>
<h3>constructor IndexError<code>(m: String): IndexError</code></h3>
<h2>class Integer</h2>
<p>The <code>Integer</code> class is Lily's native numeric type. Internally, it is a wrapper
over a C int64_t.</p>
<h3>method Integer.to_bool<code>(self: Integer): Boolean</code></h3>
<p>Converts an <code>Integer</code> to a <code>Boolean</code>.</p>
<h3>method Integer.to_byte<code>(self: Integer): Byte</code></h3>
<p>Convert an <code>Integer</code> to a <code>Byte</code>, truncating the value if necessary.</p>
<h3>method Integer.to_d<code>(self: Integer): Double</code></h3>
<p>Converts an <code>Integer</code> to a <code>Double</code>. Internally, this is done by a typecast to
the <code>Double</code> type (a raw C double).</p>
<h3>method Integer.to_s<code>(self: Integer): String</code></h3>
<p>Convert an <code>Integer</code> to a <code>String</code> using base-10.</p>
<h2>class IOError</h2>
<pre><code>class IOError &lt; Exception {

}
</code></pre>

<p><code>IOError</code> is a subclass of <code>Exception</code> that is raised when an IO operation fails
or does not have permission.</p>
<h3>constructor IOError<code>(m: String): IOError</code></h3>
<h2>class KeyError</h2>
<pre><code>class KeyError &lt; Exception {

}
</code></pre>

<p><code>KeyError</code> is a subclass of <code>Exception</code> that is raised when trying to get an
item from a <code>Hash</code> that does not exist.</p>
<h3>constructor KeyError<code>(m: String): KeyError</code></h3>
<h2>class List</h2>
<p>The <code>List</code> class represents a container of a given type, written as
<code>List[&lt;inner type&gt;]</code>. A <code>List</code> value can be accessed through a positive index or
a negative one (with negative indexes being an offset from the end). Attempting
to access an invalid index will produce <code>IndexError</code>.</p>
<h3>method List.clear<code>[A](self: List[A])</code></h3>
<p>Removes all elements present within <code>self</code>. No error is raised if <code>self</code> is
being iterated over.</p>
<h3>method List.count<code>[A](self: List[A], fn: Function(A =&gt; Boolean)): Integer</code></h3>
<p>This calls <code>fn</code> for each element within <code>self</code>. The result of this function is
the number of times that <code>fn</code> returns <code>true</code>.</p>
<h3>method List.delete_at<code>[A](self: List[A], index: Integer)</code></h3>
<p>Attempts to remove index from the List. If index is negative, then it is
considered an offset from the end of the List.</p>
<h4>Errors</h4>
<ul>
<li><code>IndexError</code> if <code>index</code> is out of range.</li>
</ul>
<h3>method List.each<code>[A](self: List[A], fn: Function(A)): List[A]</code></h3>
<p>Calls <code>fn</code> for each element within <code>self</code>. The result of this function is
<code>self</code>, so that this method can be chained with others.</p>
<h3>method List.each_index<code>[A](self: List[A], fn: Function(Integer)): List[A]</code></h3>
<p>Calls <code>fn</code> for each element within <code>self</code>. Rather than receive the elements of
<code>self</code>, <code>fn</code> instead receives the index of each element.</p>
<h3>method List.fill<code>[A](count: Integer, value: A): List[A]</code></h3>
<p>This createa a new <code>List</code> that contains <code>value</code> repeated <code>count</code> times.</p>
<h4>Errors</h4>
<ul>
<li><code>ValueError</code> if <code>count</code> is less than 1.</li>
</ul>
<h3>method List.fold<code>[A](self: List[A], start: A, fn: Function(A, A =&gt; A)): A</code></h3>
<p>This calls <code>fn</code> for each element present within <code>self</code>. The first value sent to
<code>fn</code> is initially <code>start</code>, but will later be the result of <code>fn</code>. Therefore, the
value as it accumulates can be found in the first value sent to <code>fn</code>.</p>
<p>The result of this function is the result of doing an accumulation on each
element within <code>self</code>.</p>
<h3>method List.insert<code>[A](self: List[A], index: Integer, value: A)</code></h3>
<p>Attempt to insert <code>value</code> at <code>index</code> within <code>self</code>. If index is negative, then
it is treated as an offset from the end of <code>self</code>.</p>
<h4>Errors</h4>
<ul>
<li><code>IndexError</code> if <code>index</code> is not within <code>self</code>.</li>
</ul>
<h3>method List.join<code>[A](self: List[A], separator: *String=""): String</code></h3>
<p>Create a <code>String</code> consisting of the elements of <code>self</code> interleaved with
<code>separator</code>. The elements of self are converted to a <code>String</code> as if they were
interpolated. If <code>self</code> is empty, then the result is an empty <code>String</code>.</p>
<h3>method List.map<code>[A,B](self: List[A], fn: Function(A =&gt; B)): List[B]</code></h3>
<p>This calls <code>fn</code> on each element within <code>self</code>. The result of this function is a
newly-made <code>List</code> containing the results of <code>fn</code>.</p>
<h3>method List.pop<code>[A](self: List[A]): A</code></h3>
<p>Attempt to remove and return the last element within <code>self</code>.</p>
<h4>Errors</h4>
<ul>
<li><code>IndexError</code> if <code>self</code> is empty.</li>
</ul>
<h3>method List.push<code>[A](self: List[A], value: A)</code></h3>
<p>Add <code>value</code> to the end of <code>self</code>.</p>
<h3>method List.reject<code>[A](self: List[A], fn: Function(A =&gt; Boolean)): List[A]</code></h3>
<p>This calls <code>fn</code> for each element within <code>self</code>. The result is a newly-made
<code>List</code> holding each element where <code>fn</code> returns <code>false</code>.</p>
<h3>method List.select<code>[A](self: List[A], fn: Function(A =&gt; Boolean)): List[A]</code></h3>
<p>This calls <code>fn</code> for each element within <code>self</code>. The result is a newly-made
<code>List</code> holding each element where <code>fn</code> returns <code>true</code>.</p>
<h3>method List.size<code>[A](self: List[A]): Integer</code></h3>
<p>Returns the number of elements that are within <code>self</code>.</p>
<h3>method List.shift<code>[A](self: List[A]): A</code></h3>
<p>This attempts to remove the last element from <code>self</code> and return it.</p>
<h4>Errors</h4>
<ul>
<li><code>ValueError</code> if <code>self</code> is empty.</li>
</ul>
<h3>method List.slice<code>[A](self: List[A], start: *Integer=0, stop: *Integer=-1): List[A]</code></h3>
<p>Create a new <code>List</code> copying a section of <code>self</code> from <code>start</code> to <code>stop</code>.</p>
<p>If a negative index is given, it is treated as an offset from the end of <code>self</code>,
with <code>-1</code> being considered the last element.</p>
<p>On error, this generates an empty <code>List</code>. Error conditions are:</p>
<ul>
<li>Either <code>start</code> or <code>stop</code> is out of range.</li>
<li>The <code>start</code> is larger than the <code>stop</code> (reversed).</li>
</ul>
<h3>method List.unshift<code>[A](self: List[A], value: A)</code></h3>
<p>Inserts value at the front of self, moving all other elements to the right.</p>
<h2>enum Option</h2>
<pre><code>enum Option[A] {
    Some(A)
    None
}
</code></pre>

<p>The <code>Option</code> type presents a way to hold either a value of <code>A</code>, or <code>None</code>, with
<code>None</code> being valid for any <code>Option</code>. A common use for this is as a return type
for functions that may fail, but have no meaningful error message.</p>
<h3>method Option.and<code>[A, B](self: Option[A], other: Option[B]): Option[B]</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns <code>other</code>.</p>
<p>Otherwise, this returns <code>None</code>.</p>
<h3>method Option.and_then<code>[A, B](self: Option[A], fn: Function(A =&gt; Option[B])): Option[B]</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this calls <code>fn</code> with the value within the <code>Some</code>. The
result is the result of the <code>Option</code> returned by <code>fn</code>.</p>
<p>Otherwise, this returns <code>None</code>.</p>
<h3>method Option.is_none<code>[A](self: Option[A]): Boolean</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns <code>false</code>.</p>
<p>Otherwise, this returns <code>true</code>.</p>
<h3>method Option.is_some<code>[A](self: Option[A]): Boolean</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns <code>true</code>.</p>
<p>Otherwise, this returns <code>false</code>.</p>
<h3>method Option.map<code>[A, B](self: Option[A], fn: Function(A =&gt; B)): Option[B]</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns a <code>Some</code> holding the result of <code>fn</code>.</p>
<p>Otherwise, this returns <code>None</code>.</p>
<h3>method Option.or<code>[A](self: Option[A], alternate: Option[A]): Option[A]</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns <code>self</code>.</p>
<p>Otherwise, this returns <code>alternate</code>.</p>
<h3>method Option.or_else<code>[A](self: Option[A], fn: Function( =&gt; Option[A])):Option[A]</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns <code>self</code>.</p>
<p>Otherwise, this returns the result of calling <code>fn</code>.</p>
<h3>method Option.unwrap<code>[A](self: Option[A]): A</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns the value contained within.</p>
<h4>Errors</h4>
<ul>
<li><code>ValueError</code> if <code>self</code> is <code>None</code>.</li>
</ul>
<h3>method Option.unwrap_or<code>[A](self: Option[A], alternate: A):A</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns the value with <code>self</code>.</p>
<p>Otherwise, this returns <code>alternate</code>.</p>
<h3>method Option.unwrap_or_else<code>[A](self: Option[A], fn: Function( =&gt; A)):A</code></h3>
<p>If <code>self</code> is a <code>Some</code>, this returns the value with <code>self</code>.</p>
<p>Otherwise, this returns the result of calling <code>fn</code>.</p>
<h2>class RuntimeError</h2>
<pre><code>class RuntimeError &lt; Exception {

}
</code></pre>

<p><code>RuntimeError</code> is a subclass of <code>Exception</code> that is raised when the recursion
limit is exceeded, or when trying to modify a <code>Hash</code> while iterating over it.</p>
<h3>constructor RuntimeError<code>(m: String): RuntimeError</code></h3>
<h2>class String</h2>
<p>The <code>String</code> class provides a wrapper over a C char *. The <code>String</code> class is
guaranteed to have a single '\0' terminator. Additionally, a <code>String</code> is
guaranteed to always be valid utf-8.</p>
<p>The methods on the <code>String</code> class treat the underlying <code>String</code> as being
immutable, and thus always create a new <code>String</code> instead of modifying the
existing one.</p>
<h3>method String.format<code>(self: String, args: 1...): String</code></h3>
<p>This creates a new <code>String</code> by processing <code>self</code> as a format. Format specifiers
must be between braces (<code>{}</code>), and must be between <code>0</code> and <code>99</code>. Each format
specifier is replaced with the according argument, with the first argument being
at 0, the second at 1, and so on.</p>
<p>This function is a useful alternative to interpolation for situations where the
value is a long expression, or where a single value is to be repeated several
times.</p>
<h4>Errors</h4>
<ul>
<li>
<p><code>ValueError</code> if a format specifier is malformed or has too many digits.</p>
</li>
<li>
<p><code>IndexError</code> if the format specifier specifies an out-of-range argument.</p>
</li>
</ul>
<h3>method String.ends_with<code>(self: String, end: String): Boolean</code></h3>
<p>Checks if <code>self</code> ends with <code>end</code>.</p>
<h3>method String.find<code>(self: String, needle: String, start: *Integer=0): Option[Integer]</code></h3>
<p>Check for <code>needle</code> being within <code>self</code>. By default, this begins at the start of
<code>self</code>. If <code>start</code> is non-zero, then the search begins <code>start</code> bytes away from
the beginning of <code>self</code>. If <code>start</code> lies within the middle of a utf-8 codepoint,
then <code>None</code> is automatically returned.</p>
<p>If <code>needle</code> is found, the result is a <code>Some</code> holding the index.</p>
<p>Otherwise, this returns <code>None</code>.</p>
<h3>method String.html_encode<code>(self: String): String</code></h3>
<p>Check for one of <code>"&amp;"</code>, <code>"&lt;"</code>, or <code>"&gt;"</code> being within <code>self</code>.</p>
<p>If found, a new <code>String</code> is contained with any instance of the above being
replaced by an html-safe value.</p>
<p>If not found, <code>self</code> is returned.</p>
<h3>method String.is_alnum<code>(self: String):Boolean</code></h3>
<p>Return <code>true</code> if <code>self</code> has only alphanumeric([a-zA-Z0-9]+) characters, <code>false</code>
otherwise.</p>
<h3>method String.is_alpha<code>(self: String):Boolean</code></h3>
<p>Return <code>true</code> if <code>self</code> has only alphabetical([a-zA-Z]+) characters, <code>false</code>
otherwise.</p>
<h3>method String.is_digit<code>(self: String):Boolean</code></h3>
<p>Return <code>true</code> if <code>self</code> has only digit([0-9]+) characters, <code>false</code> otherwise.</p>
<h3>method String.is_space<code>(self: String):Boolean</code></h3>
<p>Returns <code>true</code> if <code>self</code> has only space(" \t\r\n") characters, <code>false</code>
otherwise.</p>
<h3>method String.lower<code>(self: String):String</code></h3>
<p>Checks if any characters within <code>self</code> are within [A-Z]. If so, it creates a new
<code>String</code> with [A-Z] replaced by [a-z]. Otherwise, <code>self</code> is returned.</p>
<h3>method String.lstrip<code>(self: String, to_strip: String):String</code></h3>
<p>This walks through <code>self</code> from left to right, stopping on the first utf-8 chunk
that is not found within <code>to_strip</code>. The result is a newly-made copy of self
without the elements within <code>to_strip</code> at the front.</p>
<h3>method String.parse_i<code>(self: String): Option[Integer]</code></h3>
<p>Attempts to convert <code>self</code> into an <code>Integer</code>. Currently, <code>self</code> is parsed as a
base-10 encoded value.</p>
<p>If the value is a valid <code>Integer</code>, then a <code>Some</code> containing the value is
returned.</p>
<p>Otherwise, <code>None</code> is returned.</p>
<h3>method String.replace<code>(self: String, needle: String, new: String): String</code></h3>
<p>Create a new <code>String</code> consisting of every <code>needle</code> replaced with <code>new</code>.</p>
<h3>method String.rstrip<code>(self: String, to_strip: String):String</code></h3>
<p>This walks through <code>self</code> from right to left, stopping on the first utf-8 chunk
that is not found within <code>to_strip</code>. The result is a newly-made copy of <code>self</code>
without the elements of <code>to_strip</code> at the end.</p>
<h3>method String.slice<code>(self: String, start: *Integer=0, stop: *Integer=-1): String</code></h3>
<p>Create a new <code>String</code> copying a section of <code>self</code> from <code>start</code> to <code>stop</code>. This
function works using byte indexes into the <code>String</code> value.</p>
<p>If a negative index is given, it is treated as an offset from the end of <code>self</code>,
with <code>-1</code> being considered the last element.</p>
<p>On error, this generates an empty <code>String</code>. Error conditions are:</p>
<ul>
<li>Either <code>start</code> or <code>stop</code> is out of range.</li>
<li>The resulting slice would not be valid utf-8.</li>
<li>The <code>start</code> is larger than the <code>stop</code> (reversed).</li>
</ul>
<h3>method String.split<code>(self: String, split_by: *String=" "):List[String]</code></h3>
<p>This attempts to split <code>self</code> using <code>split_by</code>, with a default value of a single
space.</p>
<h4>Errors</h4>
<ul>
<li><code>ValueError</code> if <code>split_by</code> is empty.</li>
</ul>
<h3>method String.starts_with<code>(self: String, with: String): Boolean</code></h3>
<p>Checks if <code>self</code> starts with <code>with</code>.</p>
<h3>method String.strip<code>(self: String, to_strip: String):String</code></h3>
<p>This walks through self from right to left, and then from left to right. The
result of this is a newly-made <code>String</code> without any elements within <code>to_strip</code>
at either end.</p>
<h3>method String.to_bytestring<code>(self: String): ByteString</code></h3>
<p>Produce a copy of <code>self</code>, as a <code>ByteString</code>. This allows per-<code>Byte</code> operations
to be performed.</p>
<h3>method String.trim<code>(self: String): String</code></h3>
<p>Checks if <code>self</code> starts or ends with any of <code>" \t\r\n"</code>. If it does, then a new
<code>String</code> is made with spaces removed from both sides. If it does not, then this
returns <code>self</code>.</p>
<h3>method String.upper<code>(self: String):String</code></h3>
<p>Checks if any characters within self are within [a-z]. If so, it creates a new
<code>String</code> with [a-z] replaced by [A-Z]. Otherwise, <code>self</code> is returned.</p>
<h2>class Tuple</h2>
<p>The <code>Tuple</code> class provides a fixed-size container over a set of types. <code>Tuple</code>
is ideal for situations where a variety of data is needed, but a class is too
complex.</p>
<p><code>Tuple</code> literals are created by <code>&lt;[value1, value2, ...]&gt;</code>. Member of the <code>Tuple</code>
class can be accessed through subscripts. Unlike <code>List</code>, <code>Tuple</code> does not
support negative indexes.</p>
<p>Operations on the <code>Tuple</code> class use the types <code>1</code> and <code>2</code>. These are special
types that match against any number of types. This allows <code>Tuple</code> operations to
work on all <code>Tuple</code> instances, regardless of the number of elements within the
<code>Tuple</code> (sometimes considered its arity).</p>
<h3>method Tuple.merge<code>(self: Tuple[1], other: Tuple[2]): Tuple[1, 2]</code></h3>
<p>Build a new <code>Tuple</code> composed of the contents of <code>self</code> and the contents of
<code>other</code>.</p>
<h3>method Tuple.push<code>[A](self: Tuple[1], other: A): Tuple[1, A]</code></h3>
<p>Build a new <code>Tuple</code> composed of the contents of <code>self</code> and <code>other</code>.</p>
<h2>class ValueError</h2>
<pre><code>class ValueError &lt; Exception {

}
</code></pre>

<p><code>ValueError</code> is a subclass of <code>Exception</code> that is raised when sending an
improper argument to a function, such as trying to call <code>List.fill</code> with a
negative amount.</p>
<h3>constructor ValueError<code>(m: String): ValueError</code></h3>
        </div>

        <!-- Bootstrap core JavaScript
        ================================================== -->
        <!-- Placed at the end of the document so the pages load faster -->
        <script src="js/jquery.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
        <script src="js/docs.min.js"></script>
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="js/ie10-viewport-bug-workaround.js"></script>
    </body>
</html>
