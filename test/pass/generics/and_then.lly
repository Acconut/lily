# This test exists because and_then requires lambdas to pull upvalue types.
# If that is not done, then this test will crash because B is not solved and
# default to any (despite having a string value inside).

define and_then[A, B, C](f: function(A => B), g: function(B => C)):function(A => C)
{
    return {|a| g(f(a)) }
}

define piped_and_then[A, B, C](f: function(A => B), g: function(B => C)):function(A => C)
{
    return {|a| a |> f |> g }
}

define f(a: string): string { return a.concat(a) }

and_then(f, f)("10")
piped_and_then(f, and_then(f, f))("10")
